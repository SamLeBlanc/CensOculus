from PyQt5.QtCore import *
from qgis.utils import iface
from os import path
import processing
import os
from qgis.core import ( QgsVectorLayer )
import requests
import json
import pandas as pd
import time
import requests, zipfile, io
from datetime import datetime

# Downloads and unzips Census shapefiles from official TIGER directories
# If the file name already exists, the method will skip download to save time
# census_geography_keys are key,value pairs containing the "Census terminology" and "Sam's terminology" for each geography
# Currently downloading the block, group, tract, and county files (the directory only has CDs for 108th and 111th Congress...dumb)
# Example url for Alaska block file --> https://www2.census.gov/geo/pvs/tiger2010st/02_Alaska/02/tl_2010_02_tabblock10.zip
def download_census_files(code):
#  census_geography_keys = [['tabblock10','blocks10'],
#                           ['tract10'   ,'tracts10'],
#                           ['county10'  ,'countys10'],
#                           ['bg10'      ,'groups10']];
  census_geography_keys = [
                           ['bg10'      ,'groups10'],
                           ];
  for web_name, my_file_name in census_geography_keys:
    file_path = f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_{my_file_name}.shp';
    if not path.exists(file_path):
      current_time = datetime.now().strftime("%H:%M");
      print(f'Downloading Census File: {web_name}  State:{code}  Start Time:{current_time}');
      download_path = f'https://www2.census.gov/geo/pvs/tiger2010st/{code}_{code_to_state_name[code]}/{code}/tl_2010_{code}_{web_name}.zip';
      response = requests.get(download_path);
      z = zipfile.ZipFile(io.BytesIO(response.content));
      z.extractall('/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/');

# Renames the downloaded Census files from download_census_files, using same census_geography_keys as before
# Files are renamed to shorter titles (blocks10, groups10, tracts10, countys10)
# Since shapefiles need 5 files to work (?) we must rename each file type in a loop
def rename_census_files(code):
#  census_geography_keys = [['tabblock10','blocks10'],
#                           ['tract10'   ,'tracts10'],
#                           ['county10'  ,'countys10'],
#                           ['bg10'      ,'groups10']];
  census_geography_keys = [
                           ['bg10'      ,'groups10'],
                           ];
  for web_name, my_file_name in census_geography_keys:
    old_path = r'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/tl_2010_' + code + '_' + web_name;
    new_path = r'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/' + code2 + '_' + my_file_name;
    file_endings = ['.shp','.prj','.shx','.dbf','.shp.xml'];
    for type in file_endings:
      if path.exists(old_path+type):
        os.rename(old_path+type, new_path+type);

# Trims unneeded fields from Census files downloaded from the TIGER database
# Generally, the only fields to be kept are: GEOID10, ALAND10, and AWATER10
# Everything else **with the exception of the name of the county** is to be deleted
# QGIS is being stupid and making me provide it with the field names to delete rather than those to be kept
# is_county_layer is a boolean denoting whether COUNTY_LAYER is being trimmed, if so, keep NAME10 field
def trim_census_layer_fields(layer,is_county_layer):
  delete_fields = ['NAME10','STATEFP10','COUNTYFP10', 'TRACTCE10', 'BLOCKCE10', 'MTFCC10', 'UR10',
                   'UACE10', 'FUNCSTAT10', 'INTPTLAT10', 'INTPTLON10' , 'NAMELSAD10', 'COUNTYNS10',
                   'LSAD10', 'CLASSFP10', 'CSAFP10', 'CBSAFP10', 'METDIVFP10', 'BLKGRPCE10'];
  if is_county_layer:
    delete_fields.pop(0);
  for f in delete_fields:
    if f in layer.fields().names():
      index = layer.fields().indexFromName(f);
      res = layer.dataProvider().deleteAttributes([index]);
      layer.updateFields();

# Three dictionaries connecting state initials, names, and FIPS code
# (01 -> 56, Alabama -> Wyoming, *Also 72->Puerto Rico )
code_to_state = {
  '01':'AL' , '02':'AK' , '04':'AZ' , '05':'AR' , '06':'CA' , '08':'CO' , '09':'CT' , '10':'DE' , '11':'DC' , '12':'FL' ,
  '13':'GA' , '15':'HI' , '16':'ID' , '17':'IL' , '18':'IN' , '19':'IA' , '20':'KS' , '21':'KY' , '22':'LA' , '23':'ME' ,
  '24':'MD' , '25':'MA' , '26':'MI' , '27':'MN' , '28':'MS' , '29':'MO' , '30':'MT' , '31':'NE' , '32':'NV' , '33':'NH' ,
  '34':'NJ' , '35':'NM' , '36':'NY' , '37':'NC' , '38':'ND' , '39':'OH' , '40':'OK' , '41':'OR' , '42':'PA' , '44':'RI' ,
  '45':'SC' , '46':'SD' , '47':'TN' , '48':'TX' , '49':'UT' , '50':'VT' , '51':'VA' , '53':'WA' , '54':'WV' , '55':'WI' ,
  '56':'WY' , '72':'PR'
}
state_to_code = {
  'AL':'01' , 'AK':'02' , 'AZ':'04' , 'AR':'05' , 'CA':'06' , 'CO':'08' , 'CT':'09' , 'DE':'10' , 'DC':'11' , 'FL':'12' ,
  'GA':'13' , 'HI':'15' , 'ID':'16' , 'IL':'17' , 'IN':'18' , 'IA':'19' , 'KS':'20' , 'KY':'21' , 'LA':'22' , 'ME':'23' ,
  'MD':'24' , 'MA':'25' , 'MI':'26' , 'MN':'27' , 'MS':'28' , 'MO':'29' , 'MT':'30' , 'NE':'31' , 'NV':'32' , 'NH':'33' ,
  'NJ':'34' , 'NM':'35' , 'NY':'36' , 'NC':'37' , 'ND':'38' , 'OH':'39' , 'OK':'40' , 'OR':'41' , 'PA':'42' , 'RI':'44' ,
  'SC':'45' , 'SD':'46' , 'TN':'47' , 'TX':'48' , 'UT':'49' , 'VT':'50' , 'VA':'51' , 'WA':'53' , 'WV':'54' , 'WI':'55' ,
  'WY':'56' , 'PR': '72'
}
code_to_state_name = {
  '01':'Alabama' , '02':'Alaska' , '04':'Arizona' , '05':'Arkansas' , '06':'California' , '08':'Colorado' , '09':'Connecticut' , '10':'Delaware' , '11':'District_of_Columbia' , '12':'Florida' ,
  '13':'Georgia' , '15':'Hawaii' , '16':'Idaho' , '17':'Illinois' , '18':'Indiana' , '19':'Iowa' , '20':'Kansas' , '21':'Kentucky' , '22':'Louisiana' , '23':'Maine' ,
  '24':'Maryland' , '25':'Massachusetts' , '26':'Michigan' , '27':'Minnesota' , '28':'Mississippi' , '29':'Missouri' , '30':'Montana' , '31':'Nebraska' , '32':'Nevada' , '33':'New_Hampshire' ,
  '34':'New_Jersey' , '35':'New_Mexico' , '36':'New_York' , '37':'North_Carolina' , '38':'North_Dakota' , '39':'Ohio' , '40':'Oklahoma' , '41':'Oregon' , '42':'Pennsylvania' , '44':'Rhode_Island' ,
  '45':'South_Carolina' , '46':'South_Dakota' , '47':'Tennessee' , '48':'Texas' , '49':'Utah' , '50':'Vermont' , '51':'Virginia' , '53':'Washington' , '54':'West_Virginia' , '55':'Wisconsin' ,
  '56':'Wyoming' , '72':'Puerto_Rico'
}

# Opens shapefiles in QGIS from all states of a desired geography
# Accepts list of strings of desired geography size as a parameter e.g. ['tracts','countys']
def open_selected_file_types_from_all_states(types):
  files = [];
  for t in types:
    if t == 'tracts': files.append('tracts10');
    elif t == 'countys': files.append('countys10');
    elif t == 'congs': files.append('congs19');
    elif t == 'blocks': files.append('blocks10');
    elif t == 'districts': files.append('districts20');
    elif t == 'groups': files.append('groups10');
  for c in reversed(code_to_state):
    for f in files:
      open_Vector_Layer_From_File('/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/' + c + code_to_state[c] + '_'+ f +'.shp', c + code_to_state[c] + '_' + f);

# Opens shapefiles in QGIS from all states for all available geographies
def open_all_files_types_from_all_states():
  files = ['tracts10','countys10','congs19','blocks10','districts20','groups10'];
  for c in reversed(code_to_state):
    for f in files:
      open_Vector_Layer_From_File('/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/' + c + code_to_state[c] + '_'+ f +'.shp', c + code_to_state[c] + '_' + f);

# Opens shapefiles in QGIS from selected states for all available geographies
# Accepts states via their FIPS code e.g. ['01','02','06']
def open_all_file_types_from_selected_states(codes):
  for c in codes:
    files = ['tracts10','countys10','congs19','blocks10','districts20','groups10'];
    for f in files:
      open_Vector_Layer_From_File('/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/' + c + code_to_state[c] + '_'+ f +'.shp', c + code_to_state[c] + '_' + f);

# Opens shapefiles in QGIS from selected states of a desired geography
# Same as the other three add functions but this one accepts two lists, one for types, one for state codes
def open_selected_file_types_from_selected_states(types,codes):
  files = [];
  for t in types:
    if t == 'tracts': files.append('tracts10');
    elif t == 'countys': files.append('countys10');
    elif t == 'congs': files.append('congs19');
    elif t == 'blocks': files.append('blocks10');
    elif t == 'districts': files.append('districts20');
    elif t == 'groups': files.append('groups10');
  for c in codes:
    for f in files:
      open_Vector_Layer_From_File('/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/' + c + code_to_state[c] + '_'+ f +'.shp', c + code_to_state[c] + '_' + f);

# Prints all layer names and field (column) names
def print_fields_from_all_layers():
  layers = QgsProject.instance().mapLayers().values();
  for layer in layers:
    print(layer.name(),layer.fields().names());

# Opens vector layer in QGIS from file path, includes parameter for new_layer_name
def open_Vector_Layer_From_File(input_file_path, new_layer_name):
  vlayer = QgsVectorLayer(input_file_path, new_layer_name, 'ogr');
  if not vlayer.isValid():
    print('Layer failed to load:', new_layer_name);
  else:
    QgsProject.instance().addMapLayer(vlayer);

# Add a field (column) to a layer in QGIS
# Parameters: layer to add to, new field name, and type (AS A STRING) ¯\_(ツ)_/¯
# Returns boolean value True if field was added, otherwise False
def add_field_to_layer(layer,field_name,type):
  if field_name not in layer.fields().names():
    res = False;
    if type == 'string': res = layer.dataProvider().addAttributes([QgsField(field_name, QVariant.String)]);
    if type == 'double': res = layer.dataProvider().addAttributes([QgsField(field_name, QVariant.Double)]);
    if type == 'int': res = layer.dataProvider().addAttributes([QgsField(field_name, QVariant.Int)]);
    if res:
         print(f'New field "{field_name}" added to layer {layer}');
    layer.updateFields();
    return True
  else:
    print(f'Field "{field_name}" -NOT- added to layer {layer}, field already exists in layer');
    return False

# Retrives data from Census API and joins it to geogrpahy file via GEOID10
# This method contains several other methods, for a description of those, refer to those methods specifically
# First, this method checks whether the API data has already been saved locally to a .csv, if so, just read it in
# If not, call get_census10_api_data for the data and api_data_to_dataframe to send it to pandas format
# Finally, add the .csv back to QGIS as delimited text layer, then join it to block layer vis GEOID10
def add_api_field_to_census_layer(layer,size,n,type,api_code):
  if size == 'block': TLA = 'BLK';
  if size == 'group': TLA = 'GRP';
  if size == 'county': TLA = 'CTY';
  field_name = TLA + str(n)
  if size in ['block']: add_field_to_layer(BLOCK_LAYER, field_name, type);
  if size in ['county']: add_field_to_layer(COUNTY_LAYER, field_name, type);
  if size in ['group']: add_field_to_layer(GROUP_LAYER, field_name, type);
  string = 'A' + str(n) + TLA;
  print(f'Adding {api_code} data to {layer}');
  file_path = f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_{size}_{api_code}.csv';
  if not path.exists(file_path):
    api_data = get_census10_api_data(size,api_code);
    api_data_to_dataframe(code2, size, api_code, api_data,"Z");
  create_csv_type_file(code2, size, api_code, type);
  N = QgsVectorLayer(f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_{size}_{api_code}.csv', string, "ogr");
  newLayer = QgsProject.instance().addMapLayer(N);
  API = QgsProject.instance().mapLayersByName(string)[0];
  join_census_api_data_to_census_layer(layer, API, 'GEOID10');

# Creates a new unique district ID tag (DIST_ID) from state, county and *county-specific*(important) unique identifier
# Attaches the new DIST_ID to all districts in DISTRICT_LAYER
# Accepts the state code and the column name of the county-specific unique ID
# Subs is the desired substring of the county specific unique identifer. i.e. if county identifer is WA12345 then subs is [2,10]
# Assigns county code 999 if District has null COUNTY_GEO
# If the county specific uniuq identifier is NOT unique, the result will be non unique DIST_IDs,
#   in this case, the method will append '*1','*2',etc. to ensure unique DIST_IDs
def create_District_ID(state_code,unique,subs):
  col_index = DISTRICT_LAYER.fields().indexFromName('DIST_ID')
  used_IDs = [];
  for i, district in enumerate(DISTRICT_LAYER.getFeatures()):
    if district['COUNTY_GEO'] == qgis.core.NULL:
      county_code = '999';
    else:
      county_code = district['COUNTY_GEO'][2:5];
    dis_code = district[unique][subs[0]:subs[1]];
    dist_id = str(state_code) + str(county_code) + str(dis_code);
    value = 1;
    new_id = dist_id;
    while new_id in used_IDs:
      new_id = str(dist_id) + '*' + str(value);
      value += 1;
    if new_id != dist_id:
      print(f'Non Unique DIST_IDs found --> Changed {dist_id} to {new_id}');
    used_IDs.append(new_id);
    attr_value={ col_index : new_id };
    res = DISTRICT_LAYER.dataProvider().changeAttributeValues({ i : attr_value });

# Identifies and records the county or CD of each voting district
# Takes in two layers: Larger (County or CD layer)* and Smaller (voting district layer)
# Could be changed to any other thing like LDs or census 'places'
# Can be used for any size jurisdiction but be careful of data size because this method checks *each* combo of large and small district
# Method also takes in the column to write to (new_FIELD_NAME) and the LARGE_ID (name) of larger area, also num, which just changes a print line
def get_district_info(LARGE_LAYER,SMALL_LAYER,new_FIELD_NAME, LARGE_ID, num):
  if num == 0: print('Finding the county of each voting district. Total counties:', LARGE_LAYER.featureCount());
  if num == 1: print('Finding the CD of each voting district. Total CDs:', LARGE_LAYER.featureCount());
  for large in LARGE_LAYER.getFeatures():
    for small in SMALL_LAYER.getFeatures():
      if small.geometry().intersects(large.geometry()):
        overlap_area = small.geometry().intersection(large.geometry()).area();
        total_area = small.geometry().area();
        percent_in_large = overlap_area / total_area;
      # if at least x% of the small is in the large then classify it as such
        if percent_in_large > 0.1:
          update_feature_at_field(SMALL_LAYER, small, new_FIELD_NAME, large[LARGE_ID]);

# Checks to make sure the newly added DIST_ID identifier is unique amoung all others in the state (and thus the country, since it includes the state code)
# Errs if DIST_IDs are not unique, otherwise prints an all clear
def check_for_DIST_ID_uniqueness():
  used_IDs = [];
  for f in DISTRICT_LAYER.getFeatures():
    check = f['DIST_ID'];
    if check not in used_IDs:
      used_IDs.append(check);
    else:
      raise Exception (f'Non-unique DIST_IDs! The DIST_ID {check} has already been used!');
  print('All DIST_IDs are unqiue');

# Run and save fixed geometries of the district file, be wary of new saved name 'districts20_fixed'
def save_fixed_district_geometry_file(code):
  fix_layer = processing.run("native:fixgeometries", {'INPUT':DISTRICT_LAYER,'OUTPUT':'fix'})['OUTPUT'];
  vlayer = QgsVectorLayer(fix_layer, code + '_districts20_fixed', "ogr");
  if not vlayer: print("Fixed Geometry Layer failed to load!");
  res = QgsProject.instance().addMapLayer(vlayer);

# Check to see if the are any NULL values for COUNTY_GEO, CD_GEO or DIST_ID in each DISTRICT feature
# NULL value means that district was missed in an assignment of county, CD or was not given a unique DIST_ID
def check_for_NULL_districts():
  nulls = [0,0,0];
  checks = ['COUNTY_GEO','CD_GEO','DIST_ID'];
  for f in DISTRICT_LAYER.getFeatures():
    for i, check in enumerate(checks):
      if f[check] == qgis.core.NULL:
        nulls[i] += 1;
      # DIST_IDs should not have length longer than 5, if they do I need to rework this
      elif i == 2 and len(f[check]) < 6:
        nulls[2] += 1;
  if sum(nulls) == 0: print('No NULL Districts for CD/COUNTY_GEO and DIST_ID!');
  else: print('NULL Districts found --> Countys:',nulls[0],'CDs:',nulls[1],'DistIDs:',nulls[2]);

# Check to see if the are any NULL values for DIST_ID in each BLOCK feature
# Returns the number of blocks with NULL for DIST_ID
def check_for_NULL_blocks():
  null_blocks = 0;
  for f in BLOCK_LAYER.getFeatures():
    if f['DIST_ID'] == qgis.core.NULL:
      null_blocks += 1;
  if null_blocks == 0: print('All blocks have valid DIST_IDs');
  else: print(f'Invalid DIST_ID. There are {null_blocks} blocks with NULL for DIST_ID')

# Removes all geographies from layer with no land area ( ALAND10 = 0 )
def remove_all_water_geos(layer):
  with edit(layer):
    request = QgsFeatureRequest().setFilterExpression('"ALAND10"=0');
    id_list = [feat.id() for feat in layer.getFeatures(request)];
    layer.deleteFeatures(id_list);
    print(f'{len(id_list)} all-water blocks removed from {layer.name()}');

# Removes all geographies from layer with no people ( API_Pop = 0 )
def remove_pop_zero_geos(layer,string):
  with edit(layer):
    request = QgsFeatureRequest().setFilterExpression(f'"A0{string}_Z"=0');
    id_list = [feat.id() for feat in layer.getFeatures(request)];
    layer.deleteFeatures(id_list);
    print(f'{len(id_list)} blocks with zero population removed from {layer.name()}');

# Run API Census 2010 request for the 'api_code' value for all geographies of that selected size in the state
# THIS IS MY PERSONAL CENSUS API KEY, don't be an asshole
# The api_code 'P001001' is total population, you can look up the rest...
# Returns the raw Census API data, to be put into a dataframe by method api_data_to_dataframe
def get_census10_api_data(size,api_code):
  api_key = 'dd677280c5e9a6f9c1f6c4929fa378c2e3f1ebc5';
  base_url = f'https://api.census.gov/data/2010/dec/sf1';
  block_url = f'{base_url}?get={api_code}&for=block:*&in=state:{code}%20county:*%20tract:*&key={api_key}';
  group_url = f'{base_url}?get={api_code}&for=block%20group:*&in=state:{code}%20county:*%20tract:*&key={api_key}';
  county_url = f'{base_url}?get={api_code}&for=county:*&in=state:{code}&key={api_key}';
  if size == 'block': url = block_url;
  if size == 'group': url = group_url;
  if size == 'county': url = county_url;
  data = requests.get(url).json();
  return data

# Reads Census API raw return from mthod get_census10_api_data into pandas DataFrame
# Saves .csv file of the synthesized GEOID10 and api_code returned values
# Returns the dataframe with just GEOID10 and api_code values
def api_data_to_dataframe(code2, size, api_code, data, field_name):
  df = pd.DataFrame(data[1:], columns=data[0]);
  df = df.rename(columns={api_code: field_name}); # May delete this in the future, might make more sense to have api_code as column title, not field_name?
  if size == 'block':
      df['GEOID10'] = df.state + df.county + df.tract + df.block;
      df.drop(columns=['state','county','tract','block'],inplace=True);
  if size == 'group':
      df['GEOID10'] = df.state + df.county + df.tract + df['block group'];
      df.drop(columns=['state','county','tract','block group'],inplace=True);
  if size == 'county':
      df['GEOID10'] = df.state + df.county;
      df.drop(columns=['state','county'],inplace=True);
  df.set_index('GEOID10',inplace=True);
  df.to_csv(index=True,path_or_buf=f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_{size}_{api_code}.csv');
  return df

# Creates a csv type file (.csvt) which designated the type (int,double,string) of csv data
# Very helpful later on in QGIS because I cannot dynamically change column type for some reason...
def create_csv_type_file(code2,size,api_code,type):
  f = open(f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_{size}_{api_code}.csvt', "w");
  if type == 'int': f.write(f'"String","Integer"');
  if type == 'double': f.write(f'"String","Double"');
  f.close()

# Joins .csv created from API data to layer based on join_field
def join_census_api_data_to_census_layer(layer, data, join_field):
  joinObject = QgsVectorLayerJoinInfo();
  joinObject.setJoinFieldName(join_field);
  joinObject.setTargetFieldName(join_field);
  joinObject.setJoinLayerId(data.id());
  joinObject.setUsingMemoryCache(True);
  joinObject.setJoinLayer(data);
  layer.addJoin(joinObject);

# Removes all the layers, duh...
def remove_all_layers():
  layers = QgsProject.instance().mapLayers().values();
  for layer in layers: QgsProject.instance().removeMapLayer(layer);

# The only class in the whole program, wahoo! --> The District Class
# Creates a District which will contain all of the info about each voting district (precinct), ya know, the main idea of the whole site
# Currently the only method (.info) is to print the District info, maybe I'll add more, maybe not...
# PROPERTIES:
# name --- this is the unique DIST_ID created earlier.
# tracts --- a list of GEOID10 strings of tracts that overlap the District's geometry.
# tract_pcts --- a list of percents of the overlapping area between the respective tract and District.
# groups --- a list of GEOID10 strings of groups that overlap the District's geometry.
# group_pcts --- a list of percents of the overlapping area between the respective group and District.
# blocks --- a list of GEOID10 strings of blocks that overlap the District's geometry.
# block_pcts --- a list of percents of the overlapping area between the respective block and District.
# pops_b --- a list of population totals based on the requested api_codes, compiled from the BLOCK level data
# pops_g --- a list of population totals based on the requested api_codes, compiled from the GROUP level data
class District:
  def __init__(self, name, tracts, tract_pcts, groups, group_pcts, blocks, block_pcts, pops_b, pops_g):
    self.name = name
    self.tracts = tracts
    self.tract_pcts = tract_pcts
    self.groups = groups
    self.group_pcts = group_pcts
    self.blocks = blocks
    self.block_pcts = block_pcts
    self.pops_b = pops_b
    self.pops_g = pops_g
  def info(self):
    print(f'name:{self.name}');
    print(f'tracts:{len(self.tracts)}');
    print(f'groups:{len(self.groups)}');
    print(f'blocks:{len(self.blocks)}');
    print(f'pops_b:{self.pops_b}');
    print(f'pops_g:{self.pops_g}');

# Filters features in a vector layer, by selecting those whose name STARTS WITH the value
# Returns the features fitting the crieria
def features_filter_starts(layer, name, value):
  string = '"'+ name +'" LIKE \'' + value + '%\'';
  features = layer.getFeatures(string);
  return features

# Filters features in a vector layer, by selecting those whose name is EXACTLY EQUAL to the value
# Returns the features fitting the crieria
def features_filter_equal(layer, name, value):
  string = '"'+ name +'" = \'' + value + '\'';
  features = layer.getFeatures(string);
  return features

# Updates a feature at a specific field...sigh
# SOMEHOW, this is so hard in QGIS but here is a method that hopefully won't break...although it always seems to...
# layer: the layer the feature is on
# feature: the feature itself
# field_name: the field name that the change is occuring to
# fix: what to change the value to
def update_feature_at_field(layer,feature,field_name,fix):
  col_index = layer.fields().indexFromName(field_name);
  attrs = { col_index : fix};
  layer.dataProvider().changeAttributeValues({ feature.id() : attrs });

# Write the d_data list to file so it can be easily retrieved and not recalculated later
# Save the file as a json dump (with a few tweaks) under the name {code2}_d_data_districts20_data.txt
def write_District_Data_to_File(d_data):
  f = open(f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_d_data_districts20_data.txt', 'w');
  count = 0;
  z = f.write('[');
  for d in d_data:
    obj = json.dumps(d.__dict__);
    z = f.write(obj);
    if count != len(d_data)-1:
      z = f.write(',\n');
    else:
      z = f.write(']');
    count = count + 1;
  f.close()

# Reads in and recreates the d_data list from the {code2}_d_data_districts20_data.txt file
# This is a list of District objects containg information from all of the voting districts in the state
# If it exists, that means it has been written by a previous version of the program
# The d_data list is created initially in tracts() and updated in groups(), then writen to file
def read_District_Data_from_File():
  with open(f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_d_data_districts20_data.txt') as f:
    obj_list = json.load(f);
  d_data = [];
  for obj in obj_list:
    new_district = District(obj['name'], obj['tracts'], obj['tract_pcts'], obj['groups'], obj['group_pcts'], obj['blocks'],obj['block_pcts'], obj['pops_b'], obj['pops_g']);
    d_data.append(new_district);
  return d_data

# Finds all of the census tracts overlapping each voting district
# d_data is a list of District objects, one for each voting district in the state
# each District is assigned a 'name', which is its unique DIST_ID
# encompassed in DIST_ID (first 5 digits) is the State and County FIPS code (999 couty code for unknown/other county), the rest is the unique county specific identiifier
# using geometry of each District, all tracts in the state are checked to see if they overlap the District
# if they overlap AT ALL, the tract is added to a list of tracts overlapping the District
# also the percent is the *percent of the tract that is in the district* this allows us to add all the blocks in that tract quickly later on
def tracts(code):
  d_data = [];
  print(f'Finding all Census tracts that overlap each of the {DISTRICT_LAYER.featureCount()} voting districts in {code2}');
  for i, district in enumerate(DISTRICT_LAYER.getFeatures()):
    if i % 250 == 0: print(i);
    name = district['DIST_ID'];
    newDistrict = District(name,[],[],[],[],[],[],[],[]);
    if district['DIST_ID'][2:5] == '999':
      selection = features_filter_starts(TRACT_LAYER,'GEOID10', str(code));
    else:
      county_fips = district['DIST_ID'][2:5];
      selection = features_filter_starts(TRACT_LAYER,'GEOID10', str(code + county_fips));
    for tract in selection:
      if tract.geometry().intersects(district.geometry()):
        overlap_area = tract.geometry().intersection(district.geometry()).area();
        tract_area = tract.geometry().area();
        percent = overlap_area/tract_area;
        newDistrict.tracts.append(tract['GEOID10']);
        newDistrict.tract_pcts.append(percent);
    d_data.append(newDistrict);
  return d_data

def tracts_z(code):
  z_data = [];
  print(f'Finding all Census tracts that overlap each of the {ZIP_LAYER.featureCount()} zip codes in {code2}');
  for i, zip in enumerate(ZIP_LAYER.getFeatures()):
    if i % 250 == 0: print(i);
    name = zip['GEOID10'];
    newZip = District(name,[],[],[],[],[],[],[],[]);
    for tract in TRACT_LAYER.getFeatures():
      if tract.geometry().intersects(zip.geometry()):
        overlap_area = tract.geometry().intersection(zip.geometry()).area();
        tract_area = tract.geometry().area();
        percent = overlap_area/tract_area;
        newZip.tracts.append(tract['GEOID10']);
        newZip.tract_pcts.append(percent);
    z_data.append(newZip);
  return z_data

# Finds all of the census groups and blocks that overlap each voting district (District) in d_data
# Uses the list d_data created in tracts(), which has a District object for each voting district in the state
# This method loops through the tracts in each district and checks whether each group in those tracts is within the District geometry
# If a group does overlap the District, then all of the blocks in that group are checked to see if they overlap as well
# If groups/blocks overlap the District they are added to the District object
# Only add the block if more than 10% of the block is in the District, to account of blocks split between more than 2 Districts*
# Update the DIST_ID field of each group and block to save which District that block is in
# This method takes up the bulk of the time, so I included several time counters to estimate preformance
def groups(d_data,code):
  print(f'Finding all Census groups and blocks that overlap each of the {DISTRICT_LAYER.featureCount()} voting districts in {code2}')
  for a, dis_obj in enumerate(d_data):
    if a % 100 == 0: print(a);
    dis_obj.groups = [];
    dis_obj.group_pcts = [];
    dis_obj.blocks = [];
    dis_obj.block_pcts = [];
    dis_obj.pops_g = [0] * 8;
    dis_obj.pops_b = [0] * 100;
    selection = features_filter_equal(DISTRICT_LAYER,'DIST_ID', dis_obj.name)
    for i, district in enumerate(selection):
      if i > 1: raise Exception(f'District ID not unique! Non-Unique DIST_ID is {dis_obj.name}');
      for j, tract in enumerate(dis_obj.tracts):
        groups_in_tract = features_filter_starts(GROUP_LAYER,'GEOID10',str(tract))
        for group in groups_in_tract:
          sum_block_pops = 0;
          if group.geometry().intersects(district.geometry()):
            update_feature_at_field(GROUP_LAYER,group,'DIST_ID',dis_obj.name)
            blocks_in_group = features_filter_starts(BLOCK_LAYER,'GEOID10',group['GEOID10']);
            for block in blocks_in_group:
              if block.geometry().intersects(district.geometry()):
                overlap_area = block.geometry().intersection(district.geometry()).area();
                block_area = block.geometry().area();
                block_percent = overlap_area/block_area;
                if block_percent > 0.1:
                  update_feature_at_field(BLOCK_LAYER,block,'DIST_ID',dis_obj.name);
                  dis_obj.blocks.append(block['GEOID10']);
                  dis_obj.block_pcts.append(block_percent);
                  sum_block_pops += block[f'A0BLK_Z']; # <-- This sums all of the blocks (by group) that overlap the district
                  for n in range(0,59):
                    dis_obj.pops_b[n] += block[f'A{n}BLK_Z'];
          if sum_block_pops > 0:
            dis_obj.groups.append(group['GEOID10']);
            group_percent = sum_block_pops/group['A0GRP_Z']; # <-- Then, we can find use this to find the percent of the population from each group that lives in the district
            # THUS, tract_pcts and block_pcts are both BY AREA while group_pcts is by POPULATION
            dis_obj.group_pcts.append(group_percent);
      update_feature_at_field(DISTRICT_LAYER,district,f'GRP0',sum_block_pops)
      for n in range(0,59):
        update_feature_at_field(DISTRICT_LAYER,district,f'BLK{n}',dis_obj.pops_b[n])
  return d_data

def groups_z(z_data,code):
  print(f'Finding all Census groups and blocks that overlap each of the {ZIP_LAYER.featureCount()} zip codes in {code2}')
  for a, dis_obj in enumerate(z_data):
    if a % 100 == 0: print(a);
    dis_obj.groups = [];
    dis_obj.group_pcts = [];
    dis_obj.blocks = [];
    dis_obj.block_pcts = [];
    dis_obj.pops_g = [0] * 8;
    dis_obj.pops_b = [0] * 1000;
    selection = features_filter_equal(ZIP_LAYER,'GEOID10', dis_obj.name)
    for i, zip in enumerate(selection):
      zip_sum = 0;
      if i > 1: raise Exception(f'Zip code not unique! Non-Unique zip code is {dis_obj.name}');
      for j, tract in enumerate(dis_obj.tracts):
        groups_in_tract = features_filter_starts(GROUP_LAYER,'GEOID10',str(tract))
        for group in groups_in_tract:
          sum_block_pops = 0;
          if group.geometry().intersects(zip.geometry()):
            blocks_in_group = features_filter_starts(BLOCK_LAYER,'GEOID10',group['GEOID10']);
            for block in blocks_in_group:
              if block.geometry().intersects(zip.geometry()):
                overlap_area = block.geometry().intersection(zip.geometry()).area();
                block_area = block.geometry().area();
                block_percent = overlap_area/block_area;
                if block_percent > 0.1:
                  dis_obj.blocks.append(block['GEOID10']);
                  dis_obj.block_pcts.append(block_percent);
                  sum_block_pops += block[f'A0BLK_Z']; # <-- This sums all of the blocks (by group) that overlap the district
                  for n in range(0,59):
                    dis_obj.pops_b[n] += block[f'A{n}BLK_Z'];
          if sum_block_pops > 0:
            dis_obj.groups.append(group['GEOID10']);
            group_percent = sum_block_pops/group['A0GRP_Z']; # <-- Then, we can find use this to find the percent of the population from each group that lives in the district
            # THUS, tract_pcts and block_pcts are both BY AREA while group_pcts is by POPULATION
            dis_obj.group_pcts.append(group_percent);
          zip_sum += sum_block_pops;
      update_feature_at_field(ZIP_LAYER,zip,f'GRP0',zip_sum)
      for n in range(0,59):
        update_feature_at_field(ZIP_LAYER,zip,f'BLK{n}',dis_obj.pops_b[n])
  return z_data

def blocks(d_data,code,num_API_asks):
  tic = time.perf_counter();
  tic0 = time.perf_counter();
  for a, dis_obj in enumerate(d_data):
    dis_obj.blocks = []
    dis_obj.block_pcts = []
    dis_obj.pops_b = [0] * num_API_asks
    selection = features_filter_equal(DISTRICT_LAYER,'DIST_ID', dis_obj.name)
    for i, district in enumerate(selection):
      if i > 1:
        raise Exception(f'District ID not unique! Non-Unique DIST_ID is {dis_obj.name}')
      for j, tract in enumerate(dis_obj.tracts):
        blocks_in_tract = features_filter_starts(BLOCK_LAYER,'GEOID10',str(tract))
        add_all_blocks_in_tract = False
        if dis_obj.tract_pcts[j] > .97:
            add_all_blocks_in_tract = True;
        for block in blocks_in_tract:
          percent_in_district = 0
          add_block = False
          if add_all_blocks_in_tract:
            add_block = True
          elif block.geometry().intersects(district.geometry()):
            overlap_area = block.geometry().intersection(district.geometry()).area();
            block_area = block.geometry().area();
            percent_in_district = overlap_area/block_area
            if percent_in_district > 0.1:
              add_block = True
          if add_block:
            dis_obj.blocks.append(block['GEOID10'])
            dis_obj.block_pcts.append(percent_in_district)
            string = f'A0BLK_Z'
            dis_obj.pops_b[0] = dis_obj.pops_b[0] + block[string]
            update_feature_at_field(BLOCK_LAYER,block,'DIST_ID',dis_obj.name)
      toc = time.perf_counter()
      #print(code,a,len(d_data),'District:',dis_obj.name,'Tracts:',len(dis_obj.tracts),'Groups:',len(dis_obj.groups),'Blocks:',len(dis_obj.blocks),'Pop_b:',dis_obj.pops_b[0],'Pop_g:',dis_obj.pops_g[0],'Time:',round(toc-tic,2),'Total:',round((toc-tic0)/60,2),'Expected:',round(((toc-tic0)/(60*(a+.1)))*len(d_data)))
      tic = time.perf_counter()
  return d_data

# This method runs through the list d_data containing info on all Districts
# and updates the DISTRICT_LAYER geometry to hold the district population totalspops_b
def update_district_population_counts(d_data):
  for a, dis_obj in enumerate(d_data):
    selection = features_filter_equal(DISTRICT_LAYER,'DIST_ID', dis_obj.name)
    for i, district in enumerate(selection):
      if i > 1:
        raise Exception(f'District ID not unique! Non-Unique DIST_ID is {dis_obj.name}')
      for n in range (0,8):
          pass
        #update_feature_at_field(DISTRICT_LAYER,district,'BLK'+str(n),dis_obj.pops_b[n])
        #update_feature_at_field(DISTRICT_LAYER,district,'GRP'+str(n),dis_obj.pops_g[n])
  for f in COUNTY_LAYER.getFeatures():
    for n in range (0,59):
      update_feature_at_field(COUNTY_LAYER,f,'CTY'+str(n),f[f'A{n}CTY_Z'])


def updateArea(layer):
  d = QgsDistanceArea()
  d.setEllipsoid('WGS84')
  for f in layer.getFeatures():
    check = 'ALAND10'
    if check in layer.fields().names():
      area = f[check]
    else:
      area = d.convertAreaMeasurement(d.measureArea(f.geometry()), QgsUnitTypes.AreaSquareKilometers);
    update_feature_at_field(layer,f,'AREA',area);

def updateDensity(layer):
  d = QgsDistanceArea()
  d.setEllipsoid('WGS84')
  for f in layer.getFeatures():
    check = 'ALAND10'
    if layer == COUNTY_LAYER:
      pop = f['CTY0'];
    elif layer == GROUP_LAYER:
      pop = f['GRP0'];
    if check in layer.fields().names():
      area = f[check]
    else:
      area = d.convertAreaMeasurement(d.measureArea(f.geometry()), QgsUnitTypes.AreaSquareKilometers);
    if pop < 1:
      density = 0
    else:
      density = area/pop
    update_feature_at_field(layer,f,'DENSITY',density);

def createPercentField(layer,field_name, total_field_name, new_field_name):
  c0 = add_field_to_layer(layer,new_field_name,'double')
  for f in layer.getFeatures():
    if min([f[field_name],f[total_field_name]]) < 1:
      value = 0
    else:
      value = f[field_name]/f[total_field_name]
    update_feature_at_field(layer,f,new_field_name,value)

def fix_and_reproject_district_layer(c,year):
  layer = QgsProject.instance().mapLayersByName(f'{c}_{year}')[0];
  parameter = {'INPUT': layer, 'TARGET_CRS': 'EPSG:4269','OUTPUT': 'memory:Reprojected'};
  result = processing.run('native:reprojectlayer', parameter);
  if result: print('District layer geometry reprojected to EPSG:4269')
  QgsProject.instance().addMapLayer(result['OUTPUT']);
  layer = QgsProject.instance().mapLayersByName('Reprojected')[0];
  parameter = {'INPUT': layer, 'OUTPUT':'memory:Fixed'};
  result = processing.run("native:fixgeometries", parameter);
  if result: print('District layer geometry fixed')
  QgsProject.instance().addMapLayer(result['OUTPUT']);
  layer = QgsProject.instance().mapLayersByName('Fixed')[0];
  _writer = QgsVectorFileWriter.writeAsVectorFormat(layer,f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_districts20','utf-8',driverName='ESRI Shapefile');
  QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName(f'{c}_{year}')[0])
  QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('Fixed')[0])
  QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('Reprojected')[0])


def callHoard(hoard):
  for i, call in enumerate(hoard):
    add_api_field_to_census_layer(COUNTY_LAYER, 'county', i ,'int', call)
    #add_api_field_to_census_layer(BLOCK_LAYER, 'block', i ,'int', call)
    add_api_field_to_census_layer(GROUP_LAYER, 'group', i ,'int', call)
    #add_field_to_layer(ZIP_LAYER,'BLK'+str(i),'int')

def RemoveAllLayersExcept():
  names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
  for layer in names:
    if (("group" in layer) or ("county" in layer)):
      pass
    else:
      QgsProject.instance().removeMapLayer(layer)

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-

codes = [
'42','44','45','46'
]
year = '2020'
for code in code_to_state:
  #remove_all_layers()
  #
  code2 = code + code_to_state[code]
  print(code2)
  #
  download_census_files(code)
  rename_census_files(code)
  #
  c = code2[2:].lower()
  #open_Vector_Layer_From_File(f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{c}_{year}.shp',f'{c}_{year}')
  #fix_and_reproject_district_layer(c,year)
  #
  #open_all_file_types_from_selected_states([code])
  open_selected_file_types_from_selected_states(['tracts'],[code])
  open_selected_file_types_from_selected_states(['groups'],[code])
  open_selected_file_types_from_selected_states(['countys'],[code])
  #open_Vector_Layer_From_File(f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/13GA_zips20.shp',f'13GA_zips20')
  #
  COUNTY_LAYER = QgsProject.instance().mapLayersByName(code2 + '_countys10')[0]
  #CONGRESS_LAYER = QgsProject.instance().mapLayersByName(code2 + '_congs19')[0]
  TRACT_LAYER = QgsProject.instance().mapLayersByName(code2 + '_tracts10')[0]
  #BLOCK_LAYER = QgsProject.instance().mapLayersByName(code2 + '_blocks10')[0]
  #DISTRICT_LAYER = QgsProject.instance().mapLayersByName(code2 + '_districts20')[0]
  GROUP_LAYER = QgsProject.instance().mapLayersByName(code2 + '_groups10')[0]
  #ZIP_LAYER = QgsProject.instance().mapLayersByName(code2 + '_zips20')[0]
  #
  trim_census_layer_fields(GROUP_LAYER,False)
  #trim_census_layer_fields(BLOCK_LAYER,False)
  trim_census_layer_fields(TRACT_LAYER,False)
  trim_census_layer_fields(COUNTY_LAYER,True)
  #
  #c2 = add_field_to_layer(DISTRICT_LAYER,'COUNTY_GEO','string')
  #c3 = add_field_to_layer(DISTRICT_LAYER,'CD_GEO','string')
  #if c2 or c3:
    #get_district_info(COUNTY_LAYER,DISTRICT_LAYER,'COUNTY_GEO','GEOID10',0);
    #get_district_info(CONGRESS_LAYER,DISTRICT_LAYER,'CD_GEO','GEOID',1);
  #c0 = add_field_to_layer(BLOCK_LAYER,'DIST_ID','string')
  #c4 = add_field_to_layer(GROUP_LAYER,'DIST_ID','string')
  #c5 = add_field_to_layer(GROUP_LAYER,'%_in_DIST','double')
  #c1 = add_field_to_layer(DISTRICT_LAYER,'DIST_ID','string')
  #if c1:
    #create_District_ID(code,'DISTRICT',[3,10])
  #
  #check_for_DIST_ID_uniqueness()
  #check_for_NULL_districts()
  #
  hoard = [
    "P001001",
    "P002001",
    "P002002",
    "P002003",
    "P002004",
    "P002005",
    "P002006",
    "P006001",
    "P006002",
    "P006003",
    "P006004",
    "P006005",
    "P006006",
    "P008001",
    "P008002",
    "P008003",
    "P008004",
    "P008005",
    "P008006",
    "P008007",
    "P008008",
    "P008009",
    "P008010",
    "P008011",
    "P008012",
    "P008013",
    "P008014",
    "P008015",
    "P008016",
    "P008017",
    "P008018",
    "P008019",
    "P008020",
    "P008021",
    "P008022",
    "P008023",
    "P008024",
    "P008025",
    "P008026",
    "P004001",
    "P004002",
    "P004003",
    "P005001",
    "P005002",
    "P005003",
    "P005004",
    "P005005",
    "P005006",
    "P005007",
    "P005008",
    "P005009",
    "P005010",
    "P005011",
    "P005012",
    "P005013",
    "P005014",
    "P005015",
    "P005016",
    "P005017",
    ];
  callHoard(hoard)
  #
  #remove_pop_zero_geos(BLOCK_LAYER,'BLK')
  remove_pop_zero_geos(GROUP_LAYER,'GRP')
  #remove_all_water_geos(BLOCK_LAYER)
  remove_all_water_geos(GROUP_LAYER)
  #
  #z_data = tracts_z(code);
  #z_data = groups_z(z_data,code);
  #d_data = tracts(code);
  #d_data = groups(d_data,code);
  #
  #file_path = f'/home/sam/Desktop/GIS Files/ALL US DATA/Statewide_Files/{code2}_d_data_districts20_data.txt'
  #if path.exists(file_path):
    #d_data = read_District_Data_from_File()
  #else:
    #d_data = tracts(code)
    #d_data = blocks(d_data,code,num_API_asks)
    #d_data = groups(d_data,code)
    #write_District_Data_to_File(d_data)
  #check_for_NULL_blocks()
  #update_district_population_counts(d_data)
  for f in COUNTY_LAYER.getFeatures():
    for n in range (0,59):
      update_feature_at_field(COUNTY_LAYER,f,'CTY'+str(n),f[f'A{n}CTY_Z'])
  for g in GROUP_LAYER.getFeatures():
    for n in range (0,59):
      update_feature_at_field(GROUP_LAYER,g,'GRP'+str(n),g[f'A{n}GRP_Z'])

for code in code_to_state:
  code2 = code + code_to_state[code]
  #COUNTY_LAYER = QgsProject.instance().mapLayersByName(code2 + '_countys10')[0]
  GROUP_LAYER = QgsProject.instance().mapLayersByName(code2 + '_groups10')[0]
  for i in range(0,59):
    #createPercentField(BLOCK_LAYER, "BLK"+str(i), "BLK0", "BLK"+str(i)+"P");
    #createPercentField(COUNTY_LAYER, "CTY"+str(i), "CTY0", "CTY"+str(i)+"P");
    createPercentField(GROUP_LAYER, "GRP"+str(i), "GRP0", "GRP"+str(i)+"P");
    #createPercentField(ZIP_LAYER, "BLK"+str(i), "BLK0", "BLK" +str(i) + "P");
  #
  c6 = add_field_to_layer(COUNTY_LAYER,'AREA','double')
  c7 = add_field_to_layer(COUNTY_LAYER,'DENSITY','double')
  updateArea(COUNTY_LAYER)
  updateDensity(COUNTY_LAYER)
  c6 = add_field_to_layer(GROUP_LAYER,'AREA','double')
  c7 = add_field_to_layer(GROUP_LAYER,'DENSITY','double')
  updateArea(GROUP_LAYER)
  updateDensity(GROUP_LAYER)
  RemoveAllLayersExcept()
  #c6 = add_field_to_layer(DISTRICT_LAYER,'AREA','double')
  #c7 = add_field_to_layer(DISTRICT_LAYER,'DENSITY','double')
  #updateArea(DISTRICT_LAYER)
  #updateDensity(DISTRICT_LAYER)
  #c6 = add_field_to_layer(ZIP_LAYER,'AREA','double')
  #c7 = add_field_to_layer(ZIP_LAYER,'DENSITY','double')
  #updateArea(ZIP_LAYER)
  #updateDensity(ZIP_LAYER)
  #for l in [COUNTY_LAYER,GROUP_LAYER]:
     #c6 = add_field_to_layer(l,'AREA','double')
     #c7 = add_field_to_layer(l,'DENSITY','double')
     #updateArea(l)
     #updateDensity(l)
  #
#add_field_to_layer(DISTRICT_LAYER,'G20PRE_01','double');
# for f in DISTRICT_LAYER.getFeatures():
#   d_votes = f['G20PREDBID'];
#   r_votes = f['G20PRERTRU'];
#   d_vote_margin = d_votes - r_votes;
#   if max([d_votes,r_votes]) > 0:
#     final_margin = d_vote_margin/(d_votes+r_votes);
#   else:
#     final_margin = 0;
#   update_feature_at_field(DISTRICT_LAYER,f,'G20PRE_01',final_margin);
#
# add_field_to_layer(DISTRICT_LAYER,'G20PRE_02','double');
# for f in DISTRICT_LAYER.getFeatures():
#   d_votes = f['G20PREDBID'];
#   area = f['AREA'];
#   if area > 0:
#     density = d_votes / area;
#   else:
#     density = 0;
#   update_feature_at_field(DISTRICT_LAYER,f,'G20PRE_02',density);
#
# add_field_to_layer(DISTRICT_LAYER,'G20PRE_03','double');
# for f in DISTRICT_LAYER.getFeatures():
#   r_votes = f['G20PRERTRU'];
#   area = f['AREA'];
#   if area > 0:
#     density = r_votes / area;
#   else:
#     density = 0;
#   update_feature_at_field(DISTRICT_LAYER,f,'G20PRE_03',density);
#
# class D:
#   def __init__(self, DIST_ID, name, COUNTY_GEO, CD_GEO):
#     self.DIST_ID = DIST_ID
#     self.name = name
#     self.COUNTY_GEO = COUNTY_GEO
#     self.CD_GEO = CD_GEO
#   def info(self):
#     print(f'name:{self.name}')
#     print(f'DIST_ID:{self.DIST_ID}');
#     print(f'COUNTY_GEO:{self.COUNTY_GEO}')
#     print(f'CD_GEO:{self.CD_GEO}')
#
# d_data2 = [];
# for i,f in enumerate(DISTRICT_LAYER.getFeatures()):
#   DIST_ID = f['DIST_ID'];
#   NAME = f['PRECINCTNA'];
#   COUNTY_GEO = f['COUNTY_GEO'];
#   CD_GEO = f['CD_GEO'];
#   newD = D(DIST_ID, NAME, COUNTY_GEO, CD_GEO)
#   d_data2.append(newD)
#   if i > 10:
#     break;
